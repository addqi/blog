# Cocos Creator Animation 组件速查笔记

> **Animation 组件**是 Cocos Creator 中驱动动画的核心。
> 它不仅能制作**序列帧动画**（切换图片），还可以制作**属性动画**，控制节点或组件上任意属性（位置、缩放、颜色、不透明度等）随时间变化。

---

## 一、动画制作流程

### 1. 创建 Animation 组件与 AnimationClip

**添加组件**
- 在场景中选中一个节点（通常作为动画“根节点”）
- 属性检查器 → **添加组件** → **其他组件** → **Animation**

**创建 AnimationClip**
- 在 Animation 组件面板中点击 **新建 AnimationClip**
- 会生成一个 `.anim` 文件，用于存储动画数据

**根节点原则**
- 如果动画涉及多个子节点
- 通常创建一个**空节点**作为根节点并挂载 Animation
- 其下所有子节点属性都可以被动画控制

---

### 2. 编辑帧动画（序列帧动画）

> 本质：随时间切换 `Sprite` 显示的图片

**步骤**
1. 目标节点需要有 `Sprite` 组件
2. 打开动画编辑器
3. 在属性列表点击 `+`
4. 选择：`cc.Sprite.spriteFrame`

**插入关键帧**
- 将资源管理器中的 `SpriteFrame` 拖到时间轴
- 会自动生成关键帧

**调整播放节奏**
- 修改帧间隔
- 或直接拖拽关键帧调整时间位置

---

### 3. 编辑属性动画

> Animation 最强大的功能：几乎所有属性都可以动画化

**可动画的属性示例**
- 节点属性：
  - `position`
  - `scale`
  - `angle`
- 组件属性：
  - `cc.Label.string`
  - `cc.UIOpacity.opacity`
  - `cc.Sprite.color`

**使用方式**
- 在动画编辑器的属性列表点击 `+`
- 选择节点 / 子节点 / 组件上的属性
- 在不同时间点修改属性值
- 自动生成平滑插值过渡

---

## 二、程序化控制动画（TypeScript）

```ts
// 获取 Animation 组件
const anim = this.node.getComponent(cc.Animation);
```

### 1. 播放与停止

```ts
anim.play('clip_name'); // 播放指定动画（会停止其他动画）
anim.play();           // 播放默认动画（defaultClip）

anim.stop();           // 停止所有动画
anim.stop('clip_name'); // 停止指定动画
```

---

### 2. 暂停与恢复

```ts
anim.pause();  // 暂停所有动画
anim.resume(); // 恢复所有动画
```

---

### 3. 平滑切换动画（CrossFade）

```ts
anim.crossFade('new_clip_name', 0.5); // 0.5 秒内平滑切换动画
```

> 常用于角色状态切换（待机 → 攻击 → 跑动），避免动画生硬切换

---

### 4. 控制播放速度与循环

```ts
const state = anim.getState('clip_name');

state.speed = 2.0;                // 播放速度（2 倍速）
state.wrapMode = cc.WrapMode.Loop; // 循环模式
state.repeatCount = 3;             // 循环次数
```

**WrapMode 常用值**
- `Normal`：播放一次
- `Loop`：循环播放
- `PingPong`：往返播放

---

### 5. 动画控制方法速查表

| 操作 | 方法 | 说明 |
|---|---|---|
| 播放 | `play([name])` | 播放指定动画，默认播放 `defaultClip` |
| 停止 | `stop([name])` | 停止指定或全部动画 |
| 暂停 | `pause([name])` | 暂停指定或全部动画 |
| 恢复 | `resume([name])` | 恢复指定或全部动画 |
| 平滑切换 | `crossFade(name, duration)` | 在指定时间内淡入淡出 |
| 控制速度 | `getState(name).speed` | 修改播放速度 |
| 设置循环 | `getState(name).wrapMode` | 设置循环模式 |

---

## 三、动画事件（动画与逻辑交互）

### 1. 帧事件（Frame Event）

> 播放到某一帧时触发

**在编辑器中添加**
- 在时间轴某一帧右键
- 选择 **添加动画事件**
- 设置：函数名 + 参数

**脚本中接收**

```ts
// 假设帧事件函数名为 onAttack，参数为 100
onAttack(damageValue: number) {
    console.log('造成伤害：', damageValue);
    // 触发攻击、音效、特效等逻辑
}
```

> ⚠️ 函数会在**动画根节点**上的所有组件中查找并调用

---

### 2. 动画生命周期事件

```ts
const anim = this.getComponent(cc.Animation);

anim.on(cc.Animation.EventType.FINISHED, (type, state) => {
    console.log(`动画 ${state.name} 播放完毕`);
    // 切换状态，如回到待机动画
}, this);
```

**常见事件类型**
- `PLAY`
- `STOP`
- `PAUSE`
- `RESUME`
- `FINISHED`
- `LASTFRAME`

---

## 四、Animation 组件重要属性（检查器）

| 属性 | 说明 |
|---|---|
| **Default Clip** | 默认动画片段，调用 `play()` 时播放 |
| **Clips** | 动画剪辑列表，可添加多个 `AnimationClip` |
| **Play On Load** | 组件加载完成后是否自动播放默认动画 |

---

## 五、使用建议（经验总结）

- **状态动画（角色）**：推荐 `crossFade` 切换
- **数值变化（UI）**：属性动画比代码插值更直观
- **关键逻辑点**：用帧事件，不要用延时
- **复杂动画**：一个 Animation 控制一个“动画单元”，避免过度耦合

---
获取动画列表
        // 使用 getRuntimeData 获取运行时数据，安全可靠
        const runtimeData: any = this.nowSpine.skeletonData.getRuntimeData?.();
        if (!runtimeData || !Array.isArray(runtimeData.animations)) {
            console.warn("没有可用动画");
            return;
        }
    
        const anims: string[] = runtimeData.animations.map((a: any) => a.name);
        console.log("动画列表:", anims);
    
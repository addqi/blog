
---

# Cocos Creator 2.x 游戏窗口与截图笔记

---

## 1. 游戏窗口相关 API

| API / 属性                   | 功能说明                                      |
| -------------------------- | ----------------------------------------- |
| `cc.view.getVisibleSize()` | 获取游戏可视区域大小（逻辑尺寸）                          |
| `cc.view.getFrameSize()`   | 获取游戏真实窗口尺寸（真实像素）                          |
| `CC_EDITOR`                | 布尔值，判断是否在编辑器环境：`true` = 编辑器，`false` = 运行时 |
| `@ts-ignore`               | 忽略下一行的 TypeScript 报错                      |
| `asset.nativeUrl`          | 资源在游戏包内的真实路径                              |

### 示例

```ts
let viewSize = cc.view.getVisibleSize();
console.log(`游戏逻辑尺寸: ${viewSize.width} x ${viewSize.height}`);

let frameSize = cc.view.getFrameSize();
console.log(`窗口真实尺寸: ${frameSize.width} x ${frameSize.height}`);

if (CC_EDITOR) {
    console.log("当前在编辑器环境");
}
```

---

## 2. 局部截图概念

* **截图需要使用额外 Canvas**，原因是引擎内部渲染机制导致不能直接读取屏幕
* **主要对象**：

  * `cc.RenderTexture` → 运行时渲染目标
  * `cc.Texture2D` → 用于保存到本地或显示的纹理
  * `cc.SpriteFrame.setFlipY(true)` → Y 轴反转纹理，保证显示正确

---

## 3. RenderTexture 初始化

```ts
this.rTexture = new cc.RenderTexture();
this.rTexture.initWithSize(
    cc.visibleRect.width, 
    cc.visibleRect.height, 
    cc.RenderTexture.DepthStencilFormat.RB_FMT_D24S8
);
```

* `RB_FMT_D24S8` 有 3 种类型可选（深度模板格式）：

  * `D24S8`
  * `D16`
  * `None`

---

## 4. 从触摸位置绘制截图

```ts
this.node.on(cc.Node.EventType.TOUCH_START, (event: cc.Event.EventTouch)=>{
    var pos = this.node.convertToNodeSpaceAR(event.getLocation());
    var texture = new cc.Texture2D();
    texture.initWithData(this._data, cc.Texture2D.PixelFormat.RGBA8888, this.targetSize.width, this.targetSize.height);
    var _node = new cc.Node();
    _node.addComponent(cc.Sprite).spriteFrame = new cc.SpriteFrame(texture);
    _node.getComponent(cc.Sprite).spriteFrame.setFlipY(true); // 反转Y轴
    this.node.addChild(_node);
    _node.setPosition(pos);
});
```

---

## 5. 局部截图流程总结

1. 创建 `RenderTexture` 并设置尺寸
2. 将 Camera 的 `targetTexture` 指向 `RenderTexture`
3. 使用 `rt.readPixels(x, y, width, height)` 读取像素数据到 Buffer
4. 创建 `Texture2D` 和 `SpriteFrame` 显示截图
5. 可选：使用 `Canvas2Image` 保存到本地或导出为 PNG/JPEG/BMP/GIF

---

## 6. 保存为图片（浏览器/Native/微信小游戏示例）

### 浏览器

```ts
this._canvas = document.createElement('canvas');
this._canvas.width = width;
this._canvas.height = height;

let ctx = this._canvas.getContext('2d');
for (let row = 0; row < height; row++) {
    let sRow = height - 1 - row;
    let imageData = ctx.createImageData(width, 1);
    let start = sRow * width * 4;
    for (let i = 0; i < width * 4; i++) {
        imageData.data[i] = arrayBuffer[start + i];
    }
    ctx.putImageData(imageData, 0, row);
}

// 使用 Canvas2Image 保存 PNG
this.canvas2image.saveAsPNG(this._canvas, width, height);
```

### Native 平台

```ts
let filePath = jsb.fileUtils.getWritablePath() + 'screenshot.png';
jsb.saveImageData(this._buffer, width, height, filePath).then(()=>{
    console.log(`保存成功: ${filePath}`);
});
```

### 微信小游戏

```ts
this._canvas.toTempFilePath({
    x: 0, y: 0, width: width, height: height,
    destWidth: width, destHeight: height,
    fileType: "png",
    success: (res) => {
        wx.saveImageToPhotosAlbum({ filePath: res.tempFilePath });
    }
});
```

---

## 7. 关键注意点

1. **Y轴反转**：

   * RenderTexture 读取像素时 Y 轴是倒置的
   * 使用 `spriteFrame.flipUVY = true` 修正
   * iOS/OSX Native 平台特殊处理，可能需要 `flipUVY = false`
2. **UI显示**：

   * 使用 `SpriteFrame` 将截图显示在任意 Node 上
   * 使用 `UITransform.setContentSize(width, height)` 设置大小
3. **Canvas 复用**：

   * 避免重复创建 DOM Canvas，可用 `clearCanvas()` 清空再绘制
4. **跨平台兼容**：

   * 浏览器、Native、微信小游戏的保存方式不同
   * Canvas2Image 工具类封装了多平台方法

---

## 8. 核心类和方法

| 类 / 方法                                                    | 功能                               |
| --------------------------------------------------------- | -------------------------------- |
| `cc.RenderTexture`                                        | 渲染目标纹理，可读取像素                     |
| `cc.Texture2D`                                            | 用于显示或存储纹理数据                      |
| `cc.SpriteFrame`                                          | 将纹理绑定到 Sprite，支持 flipUVY         |
| `Camera.targetTexture`                                    | Camera 输出到 RenderTexture         |
| `rt.readPixels(x, y, width, height)`                      | 获取像素数据到 buffer                   |
| `Canvas2Image`                                            | 将 Canvas 转换并保存为 PNG/JPEG/GIF/BMP |
| `UITransform.setContentSize()`                            | 设置节点显示尺寸                         |
| `sys.isBrowser / sys.isNative / sys.Platform.WECHAT_GAME` | 判断平台                             |

---

import { _decorator } from 'cc';
const { ccclass, property } = _decorator;
@ccclass('Canvas2Image')
export class Canvas2Image {
    public static getInstance() {
        // check if support sth.
        var $support = function () {
            var canvas = document.createElement('canvas'),
                ctx = canvas.getContext('2d');

            return {
                canvas: !!ctx,
                imageData: !!ctx.getImageData,
                dataURL: !!canvas.toDataURL,
                btoa: !!window.btoa
            };
        }();

        var downloadMime = 'image/octet-stream';

        function scaleCanvas(canvas, width, height) {
            var w = canvas.width,
                h = canvas.height;
            if (width == undefined) {
                width = w;
            }
            if (height == undefined) {
                height = h;
            }

            var retCanvas = document.createElement('canvas');
            var retCtx = retCanvas.getContext('2d');
            retCanvas.width = width;
            retCanvas.height = height;
            retCtx.drawImage(canvas, 0, 0, w, h, 0, 0, width, height);
            return retCanvas;
        }

        function getDataURL(canvas, type, width, height) {
            canvas = scaleCanvas(canvas, width, height);
            return canvas.toDataURL(type);
        }

        function saveFile(strData, type, fileName) {
            // document.location.href = strData;
            fileDownload(strData, type, fileName);
        }

        function genImage(strData) {
            var img = document.createElement('img');
            img.src = strData;
            return img;
        }
        function fixType(type) {
            type = type.toLowerCase().replace(/jpg/i, 'jpeg');
            var r = type.match(/png|jpeg|bmp|gif/)[0];
            return 'image/' + r;
        }
        function encodeData(data) {
            if (!window.btoa) { throw 'btoa undefined' }
            var str = '';
            if (typeof data == 'string') {
                str = data;
            } else {
                for (var i = 0; i < data.length; i++) {
                    str += String.fromCharCode(data[i]);
                }
            }

            return btoa(str);
        }
        function getImageData(canvas) {
            var w = canvas.width,
                h = canvas.height;
            return canvas.getContext('2d').getImageData(0, 0, w, h);
        }
        function makeURI(strData, type) {
            return 'data:' + type + ';base64,' + strData;
        }


        /**
         * create bitmap image
         * 按照规则生成图片响应头和响应体
         */
        var genBitmapImage = function (oData) {

            //
            // BITMAPFILEHEADER: http://msdn.microsoft.com/en-us/library/windows/desktop/dd183374(v=vs.85).aspx
            // BITMAPINFOHEADER: http://msdn.microsoft.com/en-us/library/dd183376.aspx
            //

            var biWidth = oData.width;
            var biHeight = oData.height;
            var biSizeImage = biWidth * biHeight * 3;
            var bfSize = biSizeImage + 54; // total header size = 54 bytes

            //
            //  typedef struct tagBITMAPFILEHEADER {
            //  	WORD bfType;
            //  	DWORD bfSize;
            //  	WORD bfReserved1;
            //  	WORD bfReserved2;
            //  	DWORD bfOffBits;
            //  } BITMAPFILEHEADER;
            //
            var BITMAPFILEHEADER = [
                // WORD bfType -- The file type signature; must be "BM"
                0x42, 0x4D,
                // DWORD bfSize -- The size, in bytes, of the bitmap file
                bfSize & 0xff, bfSize >> 8 & 0xff, bfSize >> 16 & 0xff, bfSize >> 24 & 0xff,
                // WORD bfReserved1 -- Reserved; must be zero
                0, 0,
                // WORD bfReserved2 -- Reserved; must be zero
                0, 0,
                // DWORD bfOffBits -- The offset, in bytes, from the beginning of the BITMAPFILEHEADER structure to the bitmap bits.
                54, 0, 0, 0
            ];

            //
            //  typedef struct tagBITMAPINFOHEADER {
            //  	DWORD biSize;
            //  	LONG  biWidth;
            //  	LONG  biHeight;
            //  	WORD  biPlanes;
            //  	WORD  biBitCount;
            //  	DWORD biCompression;
            //  	DWORD biSizeImage;
            //  	LONG  biXPelsPerMeter;
            //  	LONG  biYPelsPerMeter;
            //  	DWORD biClrUsed;
            //  	DWORD biClrImportant;
            //  } BITMAPINFOHEADER, *PBITMAPINFOHEADER;
            //
            var BITMAPINFOHEADER = [
                // DWORD biSize -- The number of bytes required by the structure
                40, 0, 0, 0,
                // LONG biWidth -- The width of the bitmap, in pixels
                biWidth & 0xff, biWidth >> 8 & 0xff, biWidth >> 16 & 0xff, biWidth >> 24 & 0xff,
                // LONG biHeight -- The height of the bitmap, in pixels
                biHeight & 0xff, biHeight >> 8 & 0xff, biHeight >> 16 & 0xff, biHeight >> 24 & 0xff,
                // WORD biPlanes -- The number of planes for the target device. This value must be set to 1
                1, 0,
                // WORD biBitCount -- The number of bits-per-pixel, 24 bits-per-pixel -- the bitmap
                // has a maximum of 2^24 colors (16777216, Truecolor)
                24, 0,
                // DWORD biCompression -- The type of compression, BI_RGB (code 0) -- uncompressed
                0, 0, 0, 0,
                // DWORD biSizeImage -- The size, in bytes, of the image. This may be set to zero for BI_RGB bitmaps
                biSizeImage & 0xff, biSizeImage >> 8 & 0xff, biSizeImage >> 16 & 0xff, biSizeImage >> 24 & 0xff,
                // LONG biXPelsPerMeter, unused
                0, 0, 0, 0,
                // LONG biYPelsPerMeter, unused
                0, 0, 0, 0,
                // DWORD biClrUsed, the number of color indexes of palette, unused
                0, 0, 0, 0,
                // DWORD biClrImportant, unused
                0, 0, 0, 0
            ];

            var iPadding = (4 - ((biWidth * 3) % 4)) % 4;

            var aImgData = oData.data;

            var strPixelData = '';
            var biWidth4 = biWidth << 2;
            var y = biHeight;
            var fromCharCode = String.fromCharCode;

            do {
                var iOffsetY = biWidth4 * (y - 1);
                var strPixelRow = '';
                for (var x = 0; x < biWidth; x++) {
                    var iOffsetX = x << 2;
                    strPixelRow += fromCharCode(aImgData[iOffsetY + iOffsetX + 2]) +
                        fromCharCode(aImgData[iOffsetY + iOffsetX + 1]) +
                        fromCharCode(aImgData[iOffsetY + iOffsetX]);
                }

                for (var c = 0; c < iPadding; c++) {
                    strPixelRow += String.fromCharCode(0);
                }

                strPixelData += strPixelRow;
            } while (--y);

            var strEncoded = encodeData(BITMAPFILEHEADER.concat(BITMAPINFOHEADER)) + encodeData(strPixelData);

            return strEncoded;
        };

        /**
         * saveAsImage
         * @param canvasElement
         * @param {String} image type
         * @param {Number} [optional] png width
         * @param {Number} [optional] png height
         */
        var saveAsImage = function (canvas, width, height, type, fileName) {
            /**
             * canvas.toBlob 的第三个参数。当请求图片格式为image/jpeg或者image/webp时用来指定图片展示质量。
             * 如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略。
             * 此处暂时默认设置为 1
             */
            var quality = 1.0;
            if ($support.canvas && $support.dataURL) {
                if (typeof canvas == "string") { canvas = document.getElementById(canvas); }
                if (type == undefined) { type = 'png'; }
                type = fixType(type);
                if (/bmp/.test(type)) {
                    var data = getImageData(scaleCanvas(canvas, width, height));
                    var strData = genBitmapImage(data);
                    saveFile(makeURI(strData, downloadMime), type.replace("image/", ""), fileName);
                } else {
                    
                    canvas = scaleCanvas(canvas, width, height);
                    // 如果
                    canvas.toBlob(function(blob){
                        var url = URL.createObjectURL(blob);
                        saveFile(url, type.replace("image/", ""), fileName);
                    }, type, quality)
                }
            }
        };

        var convertToImage = function (canvas, width, height, type) {
            if ($support.canvas && $support.dataURL) {
                if (typeof canvas == "string") { canvas = document.getElementById(canvas); }
                if (type == undefined) { type = 'png'; }
                type = fixType(type);

                if (/bmp/.test(type)) {
                    var data = getImageData(scaleCanvas(canvas, width, height));
                    var strData = genBitmapImage(data);
                    return genImage(makeURI(strData, 'image/bmp'));
                } else {
                    var strData: string = getDataURL(canvas, type, width, height);
                    return genImage(strData);
                }
            }
        };

        var fileDownload = function (downloadUrl, type, fileName) {
            let aLink = document.createElement('a');
            aLink.style.display = 'none';
            aLink.href = downloadUrl;
            aLink.download = fileName + "." + type;
            // 触发点击-然后移除
            document.body.appendChild(aLink);
            aLink.click();
            document.body.removeChild(aLink);
        }



        return {
            saveAsImage: saveAsImage,
            saveAsPNG: function (canvas, width, height) {
                return saveAsImage(canvas, width, height, 'png', 'defaultpng');
            },
            saveAsJPEG: function (canvas, width, height) {
                return saveAsImage(canvas, width, height, 'jpeg', 'defaultjpg');
            },
            saveAsGIF: function (canvas, width, height) {
                return saveAsImage(canvas, width, height, 'gif', 'defaultgif');
            },
            saveAsBMP: function (canvas, width, height) {
                return saveAsImage(canvas, width, height, 'bmp', 'defaultbmp');
            },

            convertToImage: convertToImage,
            convertToPNG: function (canvas, width, height) {
                return convertToImage(canvas, width, height, 'png');
            },
            convertToJPEG: function (canvas, width, height) {
                return convertToImage(canvas, width, height, 'jpeg');
            },
            convertToGIF: function (canvas, width, height) {
                return convertToImage(canvas, width, height, 'gif');
            },
            convertToBMP: function (canvas, width, height) {
                return convertToImage(canvas, width, height, 'bmp');
            }
        };
    }
}